#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{fontspec}
\usepackage{verbatim}


\usepackage{xcolor}
\pagecolor[rgb]{0.17,0.17,0.17} %black
\color[rgb]{1,1,1} %grey

\newfontfamily\mylistingsfont{Space Mono}
\definecolor{lbcolor}{rgb}{0.2,0.2,0.2}
\usepackage{wasysym}
\newfontface\emoji{Times}
\usepackage{xltxtra}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\listings_params "basicstyle={\mylistingsfont},language={C++},backgroundcolor={\color{lbcolor}},showstringspaces=false"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
\bar under
Question 1
\end_layout

\begin_layout Part
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Question
\end_layout

\begin_layout Standard
In this part (and the next one), we'll assume that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status
\end_layout

\end_inset

 contains the return value of the process (without extra information).
 This was asked on the Piazza and a TA said that the meaning is 
\begin_inset Quotes eld
\end_inset

what is the exit code
\begin_inset Quotes erd
\end_inset

 and not the actual value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
answer B - 
\begin_inset listings
lstparams "showstringspaces=false"
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

process A
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 will be printed either once or not at all.
\end_layout

\begin_deeper
\begin_layout Standard
Process A never reaches the second printf, no matter what.
 This is because the X is private to the process and not shared.
 So in the flow that reaches ProcessA, X is never changed from 
\begin_inset Formula $1$
\end_inset

 to 
\begin_inset Formula $0$
\end_inset

.
 In the second subprocess created, p1 already contains the pid from the
 first fork (the process that runs ProcessA).
 Only the flow that runs ProcessB can affect the execution of ProcessA's
 process.
 So either ProcessB will kill ProcessA before the first print, or it will
 kill it after.
 Either way, ProcessA will always be killed with signal 9 (mean\SpecialChar endofsentence
ing exit
 of 137).
\end_layout

\begin_layout Standard
after the first fork, process A starts executing its code (the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessA
\end_layout

\end_inset

 function) and prints ones the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessA
\end_layout

\end_inset

 right before entering to an infinite loop.
 the second child has the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

pid
\end_layout

\end_inset

 of the first child from his parent process, and sands a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SIGKILL
\end_layout

\end_inset

 command to process A and kills 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printf
\end_layout

\end_inset

 in the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessA
\end_layout

\end_inset

 function.
 note: the fact that process B changes his own variable 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

X
\end_layout

\end_inset

 to 0, dose not effect the value of process A - witch still stays 1.
 
\end_layout

\end_deeper
\begin_layout Enumerate
answer A - 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status: 1
\end_layout

\end_inset

 shall never be printed.
\end_layout

\begin_deeper
\begin_layout Standard
Like explained in question 1 - ProcessA will always be killed by ProcessB.
 Thus it exits on signal 9 (or more precisely exit code 
\begin_inset Formula $9+128=137$
\end_inset

) and never goes past the infinite loop to exit code 1.
\end_layout

\begin_layout Standard
The exit value of the process B is 3 because after 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessB
\end_layout

\end_inset

 returns, it goes to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printf(
\begin_inset Quotes eld
\end_inset

end
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

return 3
\end_layout

\end_inset

 in the main.
\end_layout

\end_deeper
\begin_layout Enumerate
answer C - 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status: 137
\end_layout

\end_inset

 will be printed exactly once.
\end_layout

\begin_deeper
\begin_layout Standard
When 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessB()
\end_layout

\end_inset

 executes the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset listings
inline true
status open

\begin_layout Plain Layout

killAll()
\end_layout

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 function a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

SIGKILL
\end_layout

\end_inset

 is sent to the process running 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessA()
\end_layout

\end_inset

 and terminates it.
 Thus its exit value is 
\begin_inset Formula $128+9=137$
\end_inset

.
\end_layout

\begin_layout Standard
The main process will wait for twice for children to finish (all its children).
 Exactly one will be a process that died with exit code 
\begin_inset Formula $137$
\end_inset

.
 The second (as mentioned before) existed with code 
\begin_inset Formula $3$
\end_inset

 (returned from main).
\end_layout

\end_deeper
\begin_layout Enumerate
answer A - 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status: 143
\end_layout

\end_inset

 will never be printed.
\end_layout

\begin_deeper
\begin_layout Standard
The flow that reaches 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessB()
\end_layout

\end_inset

 is only the one from the second fork (the child, not main).
\end_layout

\begin_layout Standard
The child's 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fork()
\end_layout

\end_inset

 call returns 0.
 So 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2 == 0
\end_layout

\end_inset

.
 So no process will get signal 
\begin_inset Formula $15$
\end_inset

 and the wait in the main process will not get a status of 
\begin_inset Formula $15+128$
\end_inset

 as exit code.
\end_layout

\end_deeper
\begin_layout Enumerate
answer E - 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

The end
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 will be printed exactly twice.
\end_layout

\begin_deeper
\begin_layout Standard
Both process B and the main process finishing their code successfully and
 both of them printing the end of code line (which is outside the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

if/else
\end_layout

\end_inset

 statements.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Part
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
True
\series default
 (sometimes)
\end_layout

\begin_deeper
\begin_layout Standard
In theory, the process from the first fork will not start for a while, while
 the process from the second fork will start and print the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

process B
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 message.
 Right after the print, the OS may decide to let the process from the first
 fork to run (finally) and 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

process A
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 will be printed.
\end_layout

\begin_layout Standard
This ofc doesn't happen in every run.
 It is actually much more likely that the printing order will be the other
 way around.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
True
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
In every flow (like we mentioned before), there are two prints of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

the end
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 One of them is printed in the process of the second fork, the one running
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

ProcessB
\end_layout

\end_inset

 and another flow from the main process.
 In the flow of the main process, the end message is only printed after
 both subprocesses have finished and the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status: 137
\end_layout

\end_inset

 was printed.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
False
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
Because the line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

status: 143
\end_layout

\end_inset

 is never ever printed.
 But even is 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p2
\end_layout

\end_inset

 was not 
\begin_inset Formula $0$
\end_inset

 when 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

killAll()
\end_layout

\end_inset

 (though it is always) then the process would self destruct and process
 A will stay in an infinite loop, which means that the main process will
 keep waiting forever on the second wait.
 Either way, can't both appear in the same run let alone one be before the
 other.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Section

\series bold
\bar under
Question
\end_layout

\begin_layout Enumerate
When the child process starts to run, his/hers 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FDT
\end_layout

\end_inset

 contains the file descriptor of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

 in locations 0 and 1 but in location 2 the standard_error descriptor is
 still there (meaning isn't closed).
 that means that when the child executes the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

dup(fd)
\end_layout

\end_inset

 command it puts the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fd
\end_layout

\end_inset

 in the first open slot - witch may by somewhere after slot num 2 (which
 still has its standard_error descriptor).
 then the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanf
\end_layout

\end_inset

 reads form 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

 (the parent replaced the standard input to fd) - so now 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

s
\end_layout

\end_inset

 contains 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

\begin_inset Quotes eld
\end_inset

haha
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 read from 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

 and prints them in line 18 to the standard_error - which appears on the
 screen.
\end_layout

\begin_layout Enumerate
First line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

"haha"
\end_layout

\end_inset

 caused by line 
\begin_inset Formula $5$
\end_inset

 in the code - we simply write to the file that we created.
 Second line 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

"hello"
\end_layout

\end_inset

 - as described in question 1, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FDT
\end_layout

\end_inset

 of the child contains the value of fd in slots 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 - meaning that when we execute line 
\begin_inset Formula $17$
\end_inset

 we are print to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

 and not to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

stdout
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
The third and last line would be 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

"Father finished"
\end_layout

\end_inset

 - again, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

FDT
\end_layout

\end_inset

 contains in slots 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 the value of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

fd
\end_layout

\end_inset

, thus we print to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
We'll note that the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanf
\end_layout

\end_inset

 on line 
\begin_inset Formula $16$
\end_inset

 advanced the position in the file so the next print will not override the
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

haha
\end_layout

\end_inset

 already in the file.
\end_layout

\begin_layout Standard
So the content of the file would be
\begin_inset listings
lstparams "language={C++},showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

haha
\end_layout

\begin_layout Plain Layout

hello
\end_layout

\begin_layout Plain Layout

Father finished
\end_layout

\end_inset

And a newline at the end.
\end_layout

\end_deeper
\begin_layout Enumerate
The runtime would be faster due to two less syscalls.
 Regarding the content, it would also be the same.
 The 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

scanf
\end_layout

\end_inset

 would return with 
\begin_inset Formula $0$
\end_inset

 arguments read (due to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

EOF
\end_layout

\end_inset

 encounterd) and the next write would be after the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

haha
\end_layout

\end_inset

 that was printed before (and the rest is the same ofc).
\end_layout

\begin_deeper
\begin_layout Standard
The output would be the same because the fd(s) assignments would be the
 same.
\end_layout

\end_deeper
\begin_layout Enumerate
The output, the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

's content and (maybe) the runtime would be different.
\end_layout

\begin_deeper
\begin_layout Standard
The output - Because the printing of the read
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

haha
\end_layout

\end_inset

 will now be to 
\begin_inset Formula $3$
\end_inset

 (which would be our file) and not to the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

stderr
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The file's content - Again, it would now have an extra 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

haha
\end_layout

\end_inset

 after the 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

hello
\end_layout

\end_inset

.
 So now it's
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

haha
\end_layout

\begin_layout Plain Layout

hello
\end_layout

\begin_layout Plain Layout

haha
\end_layout

\begin_layout Plain Layout

Father finished
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The runtime - A bit more complicated and a finer point.
 Assuming that printing to the screen doesn't use the disk, then printing
 to a file is slower.
 This ofc isn't always true.
 An SSD for example usually write in a 
\begin_inset Formula $4KB$
\end_inset

 chunks and the OS/DRAM (DRAM of the SSD, assuming it even has DRAM) might
 cache the content.
 Anyways, the runtime is likely slower though not always and probably not
 noticable and maybe not even measurable.
\end_layout

\end_deeper
\begin_layout Enumerate
Yes, except output.
 There will be an extra 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printf
\end_layout

\end_inset

 in the child (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

wait(NULL)
\end_layout

\end_inset

 will return immedietely because there are no pending children)
\end_layout

\begin_deeper
\begin_layout Standard
Output - Same because 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

printf
\end_layout

\end_inset

 doesn't print to screen but to 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Conrent of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

myfile
\end_layout

\end_inset

 - there will be an extra print before the child returns so now the file
 content's will be
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

haha
\end_layout

\begin_layout Plain Layout

hello
\end_layout

\begin_layout Plain Layout

haha
\end_layout

\begin_layout Plain Layout

Father finished
\end_layout

\begin_layout Plain Layout

Father finished
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The runtime will likely be increased - again, many assumptions here but
 the caching of 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

std
\end_layout

\end_inset

 will not take effect because I think it usually commits the changes when
 a 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

newline
\end_layout

\end_inset

 is encountered.
 And there are no two consecurive 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

std
\end_layout

\end_inset

 prints in the same process.
 Still, we're writing an extra line so this would take an extra syscall
 which take extra time.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_body
\end_document
