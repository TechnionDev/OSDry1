#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\series bold
\bar under
Question 1
\end_layout

\begin_layout Standard

\series bold
\bar under
Part 1
\end_layout

\begin_layout Enumerate
answer B - after the first fork, process A starts executing its code (the
 
\begin_inset Formula $ProcessA$
\end_inset

 function) and prints ones the line 
\begin_inset Formula $‚ÄùProcessA"$
\end_inset

 right before entering to an infinite loop.
 the second child has the 
\begin_inset Formula $pid$
\end_inset

 of the first child from his parent process, and sands a 
\begin_inset Formula $SIGKILL$
\end_inset

 command to process A (how is in a infinite loop) and stops him form reaching
 to the second 
\begin_inset Formula $printf$
\end_inset

 in the 
\begin_inset Formula $ProcessA$
\end_inset

 function.
 note: the fact that process B changes his own variable 
\begin_inset Formula $X$
\end_inset

 to 0, dose not effect the value of process A - witch still stays 1.
 
\end_layout

\begin_layout Enumerate
answer A - like explained in question 1 - the second child has the 
\begin_inset Formula $pid$
\end_inset

 of the first child from his parent process - thus the value of 
\begin_inset Formula $p1$
\end_inset

 in process B is the 
\begin_inset Formula $pid$
\end_inset

 of process A.
 when process B executes the 
\begin_inset Formula $killAll$
\end_inset

 function a 
\begin_inset Formula $SIGKILL$
\end_inset

 is sand to process A and terminates it.
 thus his exit value is 9 (or more precise 
\begin_inset Formula $9+128$
\end_inset

 = 137) and not 1.
 the exit value of the process B is 3 BUT the value of 
\begin_inset Formula $status$
\end_inset

 is an encoding of the exit status and some more information about the process
 (which can be printed using macros in 
\begin_inset Formula $sys/wait.h$
\end_inset

).
\end_layout

\begin_layout Enumerate
answer B - when process B executes the 
\begin_inset Formula $killAll$
\end_inset

 function a 
\begin_inset Formula $SIGKILL$
\end_inset

 is sand to process A and terminates it.
 thus his exit value is 9 (or more precise 
\begin_inset Formula $9+128=137$
\end_inset

) and not 1 + the value of X isn't changed and the process executes a infinite
 loop until being terminated.
\end_layout

\begin_layout Enumerate
answer A - when the second fork is being made the 
\begin_inset Formula $PCB$
\end_inset

 of the main process is being copied to process B - except the value of
 the result of the fork.
 the value of 
\begin_inset Formula $p2$
\end_inset

 is 0 in process B, and 
\begin_inset Formula $pid-b$
\end_inset

 in the main process.
 thus when process B executes the 
\begin_inset Formula $killAll$
\end_inset

 function, it sands a 
\begin_inset Formula $SIGKILL$
\end_inset

 signal to process num 0 - and not to himself.
\end_layout

\begin_layout Enumerate
answer E - both process B and the main process finishing their code successfully
 and both of them printing the end of code line.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
\bar under
Part 2
\end_layout

\begin_layout Enumerate
***i think the answer is true, but i'm not sure (mainly because i ran the
 program a couple of times and haven't saw that outcome //insert raise hand
 emoji)***
\end_layout

\begin_layout Enumerate
***i think the answer is true, but i'm not sure (mainly because i ran the
 program a couple of times and haven't saw that outcome //insert raise hand
 emoji)***
\end_layout

\begin_layout Enumerate
no, because i think we don't get signal143.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
\bar under
Question 2
\end_layout

\begin_layout Enumerate
when the child process starts to run, his/hers 
\begin_inset Formula $FDT$
\end_inset

 contains the file descriptor of 
\begin_inset Formula $myfile$
\end_inset

 in locations 0 and 1 but in location 2 the standard_error descriptor is
 still there (meaning isn't closed).
 that means that when the child executes the 
\begin_inset Formula $dup(fd)$
\end_inset

 command it puts the 
\begin_inset Formula $fd$
\end_inset

 in the first open slot - witch may by somewhere after slot num 2 (which
 still has its standard_error descriptor).
 then the 
\begin_inset Formula $scanf$
\end_inset

 reads form 
\begin_inset Formula $myfile$
\end_inset

 (the parent replaced the standard input to fd) - so now 
\begin_inset Formula $s$
\end_inset

 contains the first 100 bytes in 
\begin_inset Formula $myfile$
\end_inset

 and prints them in line 18 to the standard_error - appears on the screen.
\end_layout

\begin_layout Enumerate
first line 
\begin_inset Formula $"haha"$
\end_inset

 caused by line 7 in the code - we simply writing to the file that we created.
 second line 
\begin_inset Formula $"hello"$
\end_inset

 - as described in question 1, the FDT of the child contains the value of
 fd in slots 0 and 1 - meaning that when we executing line 17 we are printing
 to 
\begin_inset Formula $myfile$
\end_inset

 and not to the standard_output.
 the third and last line would be 
\begin_inset Formula $"Fatherfinished"$
\end_inset

 - again, the FDT contains in slots 0 and 1 the val of fd and thus we are
 printing to 
\begin_inset Formula $myfile$
\end_inset

.
\end_layout

\begin_layout Enumerate

\end_layout

\end_body
\end_document
